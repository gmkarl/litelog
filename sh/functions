# this should already have been set
# LITELOGDIR="${LITELOGDIR:-/usr/lib/litelog}"

# path in which logs are stored
LOGDIR="${LOGDIR:-/var/log/litelog}"

# name of system, to label logs
HOSTNAME="${HOSTNAME:-$(hostname)}"

# for duration-based logs, duration at which to open a new log
ROTATE_SECONDS=$((${ROTATE_SECONDS:- 60 * 60 * 2 }))

# for size-based logs, size at which to open a new log (not used)
ROTATE_BYTES=$((${ROTATE_BYTES:- 64 * 1024 * 1024 * 1024 }))

# number of bytes of space to keep free on partition containing $LOGDIR
TIGHT_SPACE_BYTES=$((${TIGHT_SPACE_BYTES:- ROTATE_BYTES * 3 }))

# date format for logfiles, strftime format
DATE_FORMAT="${DATE_FORMAT:-%Y-%m-%dT%H:%M:%S%z}"

# name to give logs that are writing and open, printf format
#   %s replaced with $module $date $hostname $source $compression $extension
LOGFILENAME_INPROGRESS="tmp/%s_%s_%s_%s_%s.%s"

# name to give finished data, printf format
#   %s replaced with $module $date $hostname $source $compression $extension
LOGFILENAME="%s/%s_%s_%s_%s.%s"


VIDEO_BACKEND=${VIDEO_BACKEND:-ffmpeg}
VCODEC=${VCODEC:-h264}

AUDIO_BACKEND=${AUDIO_BACKEND:-ffmpeg}
ACODEC=${ACODEC:-opus}


## convenience for sh group
LITELOGDIRSH="${LITELOGDIR}/sh"
MODULEDIR="${LITELOGDIRSH}/${MODULE}"

format_date() {
	date +"$DATE_FORMAT" -d "$*"
}

get_logfilename() {
	_template="$1"; _module="$2"; _date="$3"; _hostname="$4"; _source="$5"; _compression="$6"; _extension="$7"
	_fname="$(printf "$_template" "$_module" "$_date" "$_hostname" "$_source" "$_compression" "$_extension")"
	_dir="${_fname%/*}"
	if test "$_dir" != "$_fname"
	then
		mkdir -p "${LOGDIR}/${_dir}"
	fi
	echo "$_fname"
}

get_logfilename_inprogress() {
	get_logfilename "$LOGFILENAME_INPROGRESS" "$@"
}

get_logfilename_final() {
	get_logfilename "$LOGFILENAME" "$@"
}

get_logfilename_component() {
	_idx=$(($2))
	_rem='\(.*\)'
	_logfilename_inprogress_re="$(printf "${LOGFILENAME_INPROGRESS//./\\.}" "$_rem" "$_rem" "$_rem" "$_rem" "$_rem" "$_rem")"
	_logfilename_final_re="$(printf "${LOGFILENAME//./\\.}" "$_rem" "$_rem" "$_rem" "$_rem" "$_rem" "$_rem")"
	
	echo "$1" | sed "s!^$_logfilename_inprogress_re\$!\\$_idx!; s!^$_logfilename_final_re\$!\\$_idx!;"
}

get_logfilename_components() {
	_logfilename_full="$*"
	_logfilename="${_logfilename_full#$LOGDIR}"
	_logfilename="${_logfilename#/}"
	rPREFIX="${_logfilename_full%$_logfilename}"
	rMODULE="$(get_logfilename_component "$_logfilename" 1)"
	rDATE="$(get_logfilename_component "$_logfilename" 2)"
	rHOSTNAME="$(get_logfilename_component "$_logfilename" 3)"
	rSOURCE="$(get_logfilename_component "$_logfilename" 4)"
	rCOMPRESSION="$(get_logfilename_component "$_logfilename" 5)"
	rEXTENSION="$(get_logfilename_component "$_logfilename" 6)"
}

finalize_inprogress_logfile() {
	get_logfilename_components "$*"
	rFINALIZED="$rPREFIX$(get_logfilename_final "$rMODULE" "$rDATE" "$rHOSTNAME" "$rSOURCE" "$rCOMPRESSION" "$rEXTENSION")"
	mv "$*" "$rFINALIZED"
}

free_bytes() {
	echo $(($(stat --file-system --format="%a * %S" "$LOGDIR")))
}

size_of() {
	stat --format="%s" "$@"
}

space_is_tight() {
	test $(free_bytes) -lt $TIGHT_SPACE_BYTES
}

# true if the two provided files have durations similar within epsilon milliseconds
# Usage: duration_is_same_epsilon <path_one> <path_two> <epsilon>
# also true if path_one has a zero duration, assuming transcoding a damaged file
duration_is_same_epsilon() {
	duration1=$(duration "$1")
	duration2=$(duration "$2")
	epsilon=$(($3))
	delta=$((duration1 - duration2))
	test $duration1 -eq 0 -o \( $delta -ge -$epsilon -a $delta -le $epsilon \) 
}

# make sure space is kept free
ensure_space_free() {
	while space_is_tight
	do
		# for video, deletes an already-compressed file
		ls -d "$LITELOGDIRSH"/*/free_space.sh | sort -R | {
			read free_space_script
			module=${free_space_script%/*}
			module=${module##*/}
			echo "Drive space is getting tight, asking $module to delete an unneeded file ..."
			/bin/sh "$free_space_script"
		} || for free_space_script in "$LITELOGDIRSH"/*/free_space.sh
		# in case one free script failed, try all of them
		do
			/bin/sh "$free_space_script" || continue # try next script
			continue 2 # script succeded, check for free space again
		done
		# no scripts succeeded
		# TODO: allow a config setting that starts removing objects from git history
		echo "NO MODULE ABLE TO FREE MORE SPACE"
		return 1
	done
}

. "$LITELOGDIRSH"/video/${VIDEO_BACKEND}_functions
