# TODO

# activate an input but do nothing with it
# Usage: fake_record <input_format> <input_path> <time_in_seconds>
fake_record() {
	gst-launch-1.0 uridecodebin uri="$1"://"$2" ! fakesink &
	sleep "$3"
	kill $!
}

# replace process with a recording process
# Usage: exec_record <input_format> <input_path> <output_label>
exec_record() {
	fndate="$(format_date now)"-"%04d"

	# find a port number that works
	port=4953
	while ! gst-launch-1.0 videotestsrc num-buffers=1 ! tcpserversink port=$port
	do
		port=$((port + 1))
	done
	echo "$port" > "$TMPDIR"/litelog-sh-video-"$3"-port
	
	# splitmuxsink will handle time/size restraints for us, splitting to numbered files
	# it is not in debian jessie, but is in stretch
	
	# uses tee to write to files at the same time as providing raw frames on a tcp port
	exec gst-launch-1.0 -e uridecodebin uri="$1://$2" do-timestamp=true ! videoconvert ! tee name=streamsrc ! queue ! x264enc bitrate=102400 ! splitmuxsink muxer=matroskamux max-size-bytes="$ROTATE_BYTES" max-size-time="$ROTATE_SECONDS"000000000 location="$LOGDIR/$(get_logfilename_final video "$fndate" "$HOSTNAME" "$1" h264 mkv)" streamsrc. ! queue leaky=2 ! matroskamux ! tcpserversink port="$port"
}

# replace process with viewing process
# Usage: exec_view <output_label>
exec_view() {
	port="$(cat "$TMPDIR"/litelog-sh-video-"$1"-port)"

	exec gst-launch-1.0 tcpclientsrc port="$port" ! decodebin ! autovideosink
}

# compress a file that was not compressed on the fly
# Usage: compress <input path?
# output filename is saved in "$rCOMPRESSED"
# caller should validate and then pass to finalize_inprogress_logfile
# TODO

# output file duration in milliseconds
# Usage: duration <file>
duration() {
	echo # TODO
}
