
# replace process with a recording process
# Usage: exec_record <input_format> <input_path> <output_label>
exec_record() {
  fnprefix="$LOGDIR"/video/"$(date +"$LOGFILE_PREFIX")"_"%04d"_"$3"
  if test -n "$COMPRESS_ON_FLY"
  then
    exec ffmpeg -loglevel error -nostats -f "$1" -i "$2" -codec copy -map 0 -f segment -segment_time "$ROTATE_SECONDS" file:"$fnprefix"_raw.mkv -acodec "$ACODEC" -vcodec "$VCODEC" -map 0 -f segment -segment_time "$ROTATE_SECONDS" file:"$fnprefix"_"$ACODEC"_"$VCODEC".mkv
  else
    exec ffmpeg -loglevel error -nostats -f "$1" -i "$2" -codec copy -map 0 -f segment -segment_time "$ROTATE_SECONDS" file:"$fnprefix"_unprocessed.mkv
  fi
}

# compress a file that was not compressed on the fly
# Usage: compress <input_path>_unprocessed.mkv
# output filename is saved in rCOMPRESSED
compress() {
  rCOMPRESSED="${1%_unprocessed.mkv}_${ACODEC}_${VCODEC}.mkv" 
  ffmpeg -loglevel error -nostats -i "file:$1" -acodec "$ACODEC" -vcodec "$VCODEC" -map 0 file:"$rCOMPRESSED"
}

# output file duration in milliseconds
# Usage: duration <file>
duration() {
  # ffprobe gives a lot of different kinds of durations.
  # this code reads duration from the info log, which covers some hard to find otherwise.
  # some are still unavailable and could be calculated by going through all the frames or
  # dividing by the bitrate, but this is not done.

  # matches '  Duration: 00:00:00.00,.*'
  regexp='^\s*\S*: \([0-9][0-9]\):\([0-9][0-9]\):\([0-9][0-9]\)\.\([0-9][0-9]\),.*$'

  # converts to milliseconds, leaving a space to identify '0' prefixes
  replacement='(( \1*60+ \2)*60+ \3)*1000+ \4*10'

  # remove '0' prefixes which will improperly mark a number as octal otherwise
  fixup='s/ 0//g'

  # mash together and output
  echo $(($(
    ffprobe -loglevel info -bitexact file:"$1" 2>&1 |
    sed -ne "s/$regexp/$replacement/p" | sed -e "$fixup"
  )))
}

